syntax = "proto3";

option go_package = "internal/gossip;gossip";

import "google/protobuf/timestamp.proto";

package gossip;

// NodeState defines the health status of a node.
enum NodeState {
  NODE_STATE_UNKNOWN = 0;
  NODE_STATE_ALIVE   = 1;
  NODE_STATE_SUSPECT = 2;
  NODE_STATE_DEAD    = 3;
}

// GossipMessageType defines the type of message being transmitted.
enum GossipMessageType {
  MESSAGE_TYPE_UNKNOWN = 0;
  MESSAGE_TYPE_CACHE_SYNC = 1;
  MESSAGE_TYPE_CLUSTER_SYNC = 2;
  MESSAGE_TYPE_CONNECT = 3;
  MESSAGE_TYPE_PROBE_REQUEST = 4;
  MESSAGE_TYPE_PROBE_RESPONSE = 5;

  // New/added types for ACKs and full-sync control:
  MESSAGE_TYPE_CACHE_SYNC_ACK = 6;
  MESSAGE_TYPE_FULL_SYNC_REQUEST = 7;
  MESSAGE_TYPE_FULL_SYNC_RESPONSE = 8;
  
  // Read operations with quorum support:
  MESSAGE_TYPE_READ_REQUEST = 9;
  MESSAGE_TYPE_READ_RESPONSE = 10;
}

// NodeInfo represents metadata for a single cluster member.
message NodeInfo {
  string node_id = 1;
  string address = 2;
  google.protobuf.Timestamp last_active_ts = 3;
  NodeState state = 4;
  int64 version = 5;
}

// ConnectPayload is sent when a new node joins the cluster.
message ConnectPayload {
  string node_id = 1;
  string address = 2;
  int64 version = 3;

  // Optional HLC timestamp string (format: node:unixnano:counter)
  string hlc = 4;
}

// ClusterSyncPayload contains a list of known nodes for state synchronization.
message ClusterSyncPayload {
  repeated NodeInfo nodes = 1;
}

// ProbePayload is used for indirect failure detection.
message ProbePayload {
  string target_node_id = 1;
  string requester_id = 2;
}

// ProbeResponsePayload is the response to an indirect probe.
message ProbeResponsePayload {
  string target_node_id = 1;
  bool alive = 2;
}

// OperationType specifies the explicit action being performed on a cache item.
enum OperationType {
  OP_UNSPECIFIED = 0;
  OP_SET = 1;
  OP_DELETE = 2;
}

// StoredItem contains the actual data being stored for SET/UPDATE operations.
message StoredItem {
  fixed64 expire_at = 1;
  bytes value = 2;
}

// CacheSyncOperation defines a single, atomic change to a cache item (the delta).
message CacheSyncOperation {
  string key = 1;
  int64 client_version = 2;
  OperationType type = 3;

  oneof data_payload {
    StoredItem set_data = 4;
  }
}

// IncrementalSyncPayload defines the structure for DELTA updates.
message IncrementalSyncPayload {
  repeated CacheSyncOperation operations = 1;
  string payload_id = 2;
}

// FullStateItem represents a complete key-value entry for the Full Sync mode.
message FullStateItem {
  string key = 1;
  int64 version = 2;
  StoredItem item_data = 3;
}

// FullSyncPayload defines the structure for a COMPLETE state snapshot.
message FullSyncPayload {
  repeated FullStateItem items = 1;
  fixed64 snapshot_timestamp = 2;
}

// SyncMessage is the top-level wrapper for all CACHE synchronization data.
message SyncMessage {
  oneof sync_type {
    IncrementalSyncPayload incremental_sync = 1;
    FullSyncPayload full_sync = 2;
  }
}

// CacheSyncAckPayload is sent by a replica to acknowledge a replication OpId.
message CacheSyncAckPayload {
  string op_id = 1;
  string peer_id = 2;
  // optional: success flag (true if apply succeeded)
  bool success = 3;
}

// FullSyncRequestPayload is used to request a full state snapshot from a peer.
message FullSyncRequestPayload {
  string requester_id = 1;
}

// FullSyncResponsePayload carries the complete snapshot as a response.
message FullSyncResponsePayload {
  FullSyncPayload full_sync = 1;
}

// ReadRequestPayload is used to request a value for a specific key.
message ReadRequestPayload {
  string key = 1;
  string requester_id = 2;
  string request_id = 3;  // Unique ID for correlating request/response
}

// ReadResponsePayload carries the value and metadata for a read request.
message ReadResponsePayload {
  string key = 1;
  string request_id = 2;  // Matches the request_id from ReadRequestPayload
  bool found = 3;
  StoredItem item_data = 4;  // Only present if found = true
  int64 version = 5;
  string responder_id = 6;
}

// GossipMessage encapsulates the payload for transmission.
// NOTE: top-level fields 'signature', 'op_id', 'hlc' are placed here
// so they exist on every message without inflating each payload type.
message GossipMessage {
  GossipMessageType type = 1;
  string sender = 2;

  oneof payload {
    ConnectPayload connect_payload = 3;
    ClusterSyncPayload cluster_sync_payload = 4;
    ProbePayload probe_request_payload = 5;
    ProbeResponsePayload probe_response_payload = 6;
    SyncMessage cache_sync_payload = 7;
    CacheSyncAckPayload cache_sync_ack_payload = 8;
    FullSyncRequestPayload full_sync_request_payload = 9;
    FullSyncResponsePayload full_sync_response_payload = 10;
    ReadRequestPayload read_request_payload = 11;
    ReadResponsePayload read_response_payload = 12;
  }

  // Top-level metadata used by coordinator/replication and signing:
  // Op id used by coordinator when sending replication messages.
  string op_id = 20;

  // Optional HLC timestamp (format: node:unixnano:counter).
  string hlc = 21;

  // Signature of the canonicalized message bytes (see note below).
  bytes signature = 22;

  // Compression flag: if true, the payload is compressed with zstd
  bool compressed = 23;
}
